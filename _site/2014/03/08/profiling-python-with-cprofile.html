<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Profiling python wth cProfile</title>
        <meta name="viewport" content="width=device-width">
        <link href="http://fonts.googleapis.com/css?family=Josefin+Sans:100,400" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="/css/base.css">

    </head>
    <body itemscope itemtype="http://schema.org/WebPage">
        <div class="container">
            <header>
                <a href='/'>
                    <h1><strong>y</strong><span>michael</span></h1>
                </a>
            </header>
            <nav>
                <ul>
                    <li class='navlink'><a href="/about.html">about</a></li>
                    <li class='navlink'><a href="/posts.html">posts</a></li>
                    <li class='navlink'><a href="/projects.html">projects</a></li>
                    <li class='navlink'><a href="mailto:wrong92@gmail.com">say hi</a></li>
                </ul>
            </nav>
            <div role="main"><article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="name">
            <a href="/2014/03/08/profiling-python-with-cprofile.html" itemprop="url">Profiling python wth cProfile</a>
        </h1>
        <time pubdate itemprop="datePublished" datetime="2014-03-08 00:00:00 +0800" content="2014-03-08 00:00:00 +0800">
            08 Mar 2014
        </time>
    </header>

    <div class='post'><p>A couple of days ago, I had an assignment for an <a href='comp.nus.edu.sg/~kanmy/courses/3245_2014/index.html'>Information Retrieval class</a> that basically involved:</p>

<ol>
<li>Indexing a large corpus <strong>(Reuters from <code>nltk</code>)</strong></li>

<li>Searching it using boolean queries <strong>(eg. <code>bill AND gates</code>)</strong></li>
</ol>

<p>For the second part of the of the assignment, performance was pretty important. Since we would want to return results for the user&#8217;s queries quickly.</p>

<p><em>This blogpost is basically about how I used python&#8217;s cProfile to identify and fix bottlenecks/slow parts in my code.</em> Most of these bottlenecks would have been hard to identify without the profiler.</p>

<p>During my internship at Quora, one of the things I worked on was POST speed improvements for core actions across the product. It was my first brush with trying to speed work and the main lesson I took away was the importance of measuring and profiling before attempting to optimise.</p>

<blockquote>
<p>&#8220;Bottlenecks occur ins surprising places, so don&#8217;t try to second guess and put in a speed hack until you have proven that&#8217;s where the bottleneck is.&#8221; - Rob Pike</p>
</blockquote>

<h2 id='measure'>Measure</h2>

<p>After getting a working submission out. I proceeded to measure my code. Since this program was meant to run as a script from the command line, I used the simple <code>time</code> commandline tool to roughly benchmark how fast my code was.</p>

<pre><code>time python search.py
# real    0m1.521s
# user    0m1.250s
# sys     0m0.142s</code></pre>

<h2 id='profile'>Profile</h2>

<p>Once I was happy with the measurement, proceeded to profile my code using cProfile.</p>

<pre><code>python -m cProfile -o profile_output search.py</code></pre>

<p>The <code>-o</code> flag basically specifies an output filename for cProfile to write its output to. (Without which, it&#8217;ll simply spit out the stats to the stdout, which is undesirable since we&#8217;d be unable to sort/drill down into specific function.)</p>

<h2 id='making_sense_of_the_cprofile_output'>Making sense of the cProfile output</h2>

<p>The cProfile output is a basically binary file that contains the following information:</p>

<p>For each function called in the python program:</p>

<ul>
<li>How long each call took (percall, inclusive and exclusive)</li>

<li>How many times it was called (ncalls)</li>

<li>How long it took (cumtime: includes the times of other functions it calls)</li>

<li>How long it actually took (tottime: excludes the times of other functions)</li>

<li>What functions it called (callers)</li>

<li>What functions called it (callees)</li>
</ul>

<p><em>If you didn&#8217;t specify the output, you&#8217;ll basically only get a dump of the information without the caller/callees part. (Which is quite helpful in making sense of everything). You&#8217;d also lose the ability to dynamically re-sort the information based on your preferred metric (unless you re-profile it with a <code>-s</code> flag (I think)).</em></p>

<h3 id='reading_the_cprofile_binary_output_file'>Reading the cProfile binary output file</h3>

<p>In order to read this binary file, python provides a pstats.Stats class that happily spits out the various infomation for you in a python shell (when called with the relevant methods).</p>

<p>I found this rather tedious and googling around for an easier way to read this binary file yield nothing. I wanted a simple way to:</p>

<ol>
<li>See the information</li>

<li>Sort with a single click</li>

<li>Drill down to functions with a single click</li>
</ol>

<p><em>(These as oppose to manually calling methods on the Stats object each time.)</em></p>

<p>So I wrote this: <a href='https://github.com/ymichael/cprofilev'>CProfileV</a>. Which is bacially a thin wrapper for viewing python cProfile output in your browser. Yay!</p>

<pre><code># Install cprofilev
$ sudo pip install cprofilev

# Call it with your cprofile output
$ cprofilev /path/to/cprofile/output

# Navigate to http://localhost:4000</code></pre>

<p><img alt='cprofilev1' src='/img/blog/cprofilev1.png' /></p>

<h3 id='finding_the_bottlenecks'>Finding the bottlenecks</h3>

<p>The pstats.Stats object allows you to sort by the various keys and their combinations. Most often, I find that the most useful sort keys are:</p>

<ul>
<li>cumulative time</li>

<li>total time</li>

<li>calls <em>(to find unneccessary function calls (objects being created in a loop for instance))</em></li>
</ul>

<p>Sorting by total time for me yielded this:</p>

<p><img alt='cprofilev2-tottime' src='/img/blog/cprofilev2-tottime.png' /></p>

<p>The top line stood out to me. The function <code>not_operation</code> was taking a suspiciously long time.</p>

<p>Clicking into the <code>not_operation</code> showed that the functions it was calling were not taking a lot of time. (Implying that the slowness was due to some code within the function itself.)</p>

<p><img alt='cprofilev3-not-operation' src='/img/blog/cprofilev3-not-operation.png' /></p>

<pre><code># line 76 of search_index.py
def not_operation(operand, dictionary, pfile):
    &quot;&quot;&quot;Performs the operation `NOT operand`.&quot;&quot;&quot;

    # A list of all the documents (sorted)
    all_docs = dictionary.all_docs()

    # A list of the documents matching `operand` (sorted)
    results = get_results(operand, dictionary, pfile, force_list=True)

    return [doc for doc in all_docs if doc not in results]</code></pre>

<p>So it turns out that the list comprehension in the function was basically really inefficient. It became super obvious once I narrowed down that <code>not_operation</code> was slow.</p>

<h3 id='optimisefix_ineffient_code'>Optimise/Fix ineffient code</h3>

<p>Excited to have found a possible bottleneck, I quickly implemented a fix.</p>

<pre><code># the fix.
def not_operation(operand, dictionary, pfile):
    &quot;&quot;&quot;Performs the operation `NOT operand`.&quot;&quot;&quot;

    # A list of all the documents (sorted)
    all_docs = dictionary.all_docs()

    # A list of the documents matching `operand` (sorted)
    results = get_results(operand, dictionary, pfile, force_list=True)

    return list_a_and_not_list_b(all_docs, results)


def list_a_and_not_list_b(a, b):
    &quot;&quot;&quot;Returns `a AND NOT b`.

    Both a and b are expected to be sorted lists.

    &quot;&quot;&quot;
    results = []
    idx_a = 0
    idx_b = 0
    while idx_a &lt; len(a) and idx_b &lt; len(b):
        if a[idx_a] &lt; b[idx_b]:
            results.append(a[idx_a])
            idx_a += 1
        elif b[idx_b] &lt; a[idx_a]:
            idx_b += 1
        else:
            idx_a += 1
            idx_b += 1

    while idx_a &lt; len(a):
        results.append(a[idx_a])
        idx_a += 1

    return results</code></pre>

<h2 id='measure_again'>Measure again</h2>

<p>Measuring the time taken showed promising results. With this fix, the time taken dropped from roughly 1.5s to 1.15s.</p>

<pre><code>time python search.py
# real    0m1.160s
# user    0m1.018s
# sys     0m0.133s</code></pre>

<p>Profiling the code showed that the slowness was no longer coming from <code>not_operation</code>.</p>

<p><img alt='cprofilev4-not-operation' src='/img/blog/cprofilev4-not-operation.png' /></p>

<h2 id='rinse_and_repeat'>Rinse and repeat</h2>

<p>This time though, the most of the time seemed to be spent in the <code>list_a_and_not_list_b</code> operation.</p>

<p><img alt='cprofilev5-bool-operation' src='/img/blog/cprofilev4-bool-operation.png' /></p>

<p>In particular, I seemed to be doing 200k <code>len</code> operations and 115 <code>append</code> operations on some list objects.</p>

<p>This seemed like a red-flag so I took a closer look at the <code>list_a_and_not_list_b</code> function.</p>

<p>It turns out that I really didn&#8217;t need the while loop at the end of the function.</p>

<pre><code>    # From this.
    while idx_a &lt; len(a):
        results.append(a[idx_a])
        idx_a += 1

    # To this.
    results.extend(a[idx_a:])</code></pre>

<p>Measuring with this new change:</p>

<pre><code>time python search.py
real    0m0.895s
user    0m0.771s
sys     0m0.122s</code></pre>

<p><em>Woot! Got it to run under a second!</em></p>

<h2 id='summary'>Summary</h2>

<p>Overall, I&#8217;m pretty happy with the performance gain I got. I did a couple more that I didn&#8217;t cover here (some other boolean operations were performing poorly under other testcases). Its a pretty cool feeling to methodically find bottlenecks and fix them.</p></div>
</article></div>
            <footer>
                <a href="https://github.com/ymichael" target="_blank">
                    <div class="icon github"></div>
                </a>
                <a href="http://twitter.com/_ymichael" target="_blank">
                    <div class="icon twitter"></div>
                </a>
                <a href="https://www.quora.com/Michael-Yong" target="_blank">
                    <div class="icon quora"></div>
                </a>
            </footer>
        </div>
    </body>
</html>
