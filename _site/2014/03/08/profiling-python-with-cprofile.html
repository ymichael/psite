<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Profiling python wth cProfile</title>
        <meta name="viewport" content="width=device-width">
        <link href="http://fonts.googleapis.com/css?family=Josefin+Sans:100,400,600" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="/css/base.css">
        <link rel="stylesheet" href="/css/syntax.css">


        <!-- facebook meta tags -->
        
            <meta property="og:title" content="Profiling python wth cProfile"/>
            <meta property="og:site_name" content="ymichael"/>
            <meta property="og:description" content="A couple of days ago, I had an assignment for an [Information Retrieval
class](comp.nus.edu.sg/~kanmy/courses/3245_2014/index.html)
that basically involved:

"/>
        

    </head>
    <body itemscope itemtype="http://schema.org/WebPage">
        <div class="container">
            
                <nav>
                    <ul>
                        <li class='navlink'><a href='/'>~/</a></li>
                        <li class='navlink'><a href="/posts.html">posts</a></li>
                        <li class='navlink'><a href="/projects.html">projects</a></li>
                        <li class='navlink'><a href="mailto:wrong92@gmail.com">say hi</a></li>
                    </ul>
                </nav>
                <div role="main"><article class='post' itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <time pubdate itemprop="datePublished" datetime="2014-03-08 00:00:00 +0800" content="2014-03-08 00:00:00 +0800">
            08 Mar 2014
        </time>
        <h1 class='post_title' itemprop="name">Profiling python wth cProfile</h1>
    </header>
    <section><p>A couple of days ago, I had an assignment for an <a href='comp.nus.edu.sg/~kanmy/courses/3245_2014/index.html'>Information Retrieval class</a> that basically involved:</p>

<ol>
<li>Indexing a large corpus <em>(Reuters from <code>nltk</code>)</em></li>

<li>Searching it using boolean queries <em>(eg. <code>bill AND gates</code>)</em></li>
</ol>

<p>For the second part of the of the assignment, performance was pretty important. Since we would want to return results for the user&#8217;s queries quickly.</p>

<p><strong>This blogpost is basically about how I used python&#8217;s cProfile to identify and fix bottlenecks/slow parts in my code.</strong> Most of these bottlenecks would have been hard to identify without the profiler. <!--more--></p>

<p>During my internship at Quora, one of the things I worked on was POST speed improvements for core actions across the product. It was my first brush with speed work and the main lesson I took away was the importance of measuring and profiling before attempting to optimise.</p>

<blockquote>
<p>&#8220;Bottlenecks occur ins surprising places, so don&#8217;t try to second guess and put in a speed hack until you have proven that&#8217;s where the bottleneck is.&#8221; - Rob Pike</p>
</blockquote>

<h2 id='measure'>Measure</h2>

<p>After getting a working submission out. I proceeded to measure/benchmark my code. Since this program was meant to run as a script from the command line, I used the simple <code>time</code> command-line tool to roughly benchmark how fast my code was.</p>
<div class='highlight'><pre><code class='bash'><span class='nv'>$ </span><span class='nb'>time </span>python search.py
<span class='c'># real    0m1.521s</span>
<span class='c'># user    0m1.250s</span>
<span class='c'># sys     0m0.142s</span>
</code></pre></div>
<h2 id='profile'>Profile</h2>

<p>Once I was happy with the measurement, I proceeded to profile my code using <code>cProfile</code>.</p>
<div class='highlight'><pre><code class='bash'><span class='nv'>$ </span>python -m cProfile -o profile_output search.py
</code></pre></div>
<p>The <code>-o</code> flag basically specifies an output filename for cProfile to write its output to. (Without which, it&#8217;ll simply spit out the stats to the stdout, which is undesirable since we&#8217;d be unable to sort/drill down into specific functions.)</p>

<h2 id='making_sense_of_the_cprofile_output'>Making sense of the cProfile output</h2>

<p>The cProfile output is a basically binary file that contains the following information:</p>

<p><em>(For each function called in the python program)</em></p>

<ul>
<li>How long each call took (percall, inclusive and exclusive)</li>

<li>How many times it was called (ncalls)</li>

<li>How long it took (cumtime: includes the times of other functions it calls)</li>

<li>How long it actually took (tottime: excludes the times of other functions)</li>

<li>What functions it called (callers)</li>

<li>What functions called it (callees)</li>
</ul>

<p><strong>If you didn&#8217;t specify the output, you&#8217;ll basically only get a dump of the information without the caller/callees part. (Which is quite helpful in making sense of everything). You&#8217;d also lose the ability to dynamically re-sort the information based on your preferred metric (unless you re-profile it with a <code>-s</code> flag (I think)).</strong></p>

<h3 id='reading_the_cprofile_binary_output_file'>Reading the cProfile binary output file</h3>

<p>In order to read this binary file, python provides a pstats.Stats class that happily spits out the various infomation for you in a python shell (when called with the relevant methods).</p>

<p>I found this rather tedious and <a href='http://blog.ludovf.net/python-profiling-cprofile/'>googling</a> <a href='http://pymotw.com/2/profile/'>around</a> for an easier way to read this binary file yield nothing. I just wanted a simple way to:</p>

<ol>
<li>See all the information</li>

<li>Sort them with a single click</li>

<li>Drill down to functions (and their callers and callees) with a single click</li>
</ol>

<p><em>(These as oppose to manually calling methods on the Stats object each time.)</em></p>

<p>So I wrote this: <a href='https://github.com/ymichael/cprofilev'>CProfileV</a>. Which is bacially a thin wrapper for viewing python cProfile output in your browser. Yay!</p>
<div class='highlight'><pre><code class='bash'><span class='c'># Install cprofilev</span>
<span class='nv'>$ </span>sudo pip install cprofilev

<span class='c'># Call it with your cprofile output</span>
<span class='nv'>$ </span>cprofilev /path/to/cprofile/output

<span class='c'># Navigate to http://localhost:4000</span>
</code></pre></div>
<p><img alt='cprofilev1' src='/img/blog/cprofilev1.png' /></p>

<h3 id='finding_the_bottlenecks'>Finding the bottlenecks</h3>

<p>The pstats.Stats object allows you to sort by the various keys and their combinations. Most often, I find that the most useful sort keys are:</p>

<ul>
<li>cumulative time</li>

<li>total time</li>

<li>calls <em>(to find unneccessary function calls (objects being created in a loop for instance))</em></li>
</ul>

<p>Sorting by total time for me yielded this:</p>

<p><img alt='cprofilev2-tottime' src='/img/blog/cprofilev2-tottime.png' /></p>

<p>The top line stood out to me. The function <code>not_operation</code> was taking a suspiciously long time.</p>

<p>Clicking into the <code>not_operation</code> showed that the functions it was calling were not taking a lot of time. <strong>(Implying that the slowness was due to some code within the function itself.)</strong></p>

<p><img alt='cprofilev3-not-operation' src='/img/blog/cprofilev3-not-operation.png' /></p>
<div class='highlight'><pre><code class='python'><span class='c'># line 76 of search_index.py</span>
<span class='k'>def</span> <span class='nf'>not_operation</span><span class='p'>(</span><span class='n'>operand</span><span class='p'>,</span> <span class='n'>dictionary</span><span class='p'>,</span> <span class='n'>pfile</span><span class='p'>):</span>
    <span class='sd'>&quot;&quot;&quot;Performs the operation `NOT operand`.&quot;&quot;&quot;</span>

    <span class='c'># A list of all the documents (sorted)</span>
    <span class='n'>all_docs</span> <span class='o'>=</span> <span class='n'>dictionary</span><span class='o'>.</span><span class='n'>all_docs</span><span class='p'>()</span>

    <span class='c'># A list of the documents matching `operand` (sorted)</span>
    <span class='n'>results</span> <span class='o'>=</span> <span class='n'>get_results</span><span class='p'>(</span><span class='n'>operand</span><span class='p'>,</span> <span class='n'>dictionary</span><span class='p'>,</span> <span class='n'>pfile</span><span class='p'>,</span> <span class='n'>force_list</span><span class='o'>=</span><span class='bp'>True</span><span class='p'>)</span>

    <span class='k'>return</span> <span class='p'>[</span><span class='n'>doc</span> <span class='k'>for</span> <span class='n'>doc</span> <span class='ow'>in</span> <span class='n'>all_docs</span> <span class='k'>if</span> <span class='n'>doc</span> <span class='ow'>not</span> <span class='ow'>in</span> <span class='n'>results</span><span class='p'>]</span>
</code></pre></div>
<p>So it turns out that the list comprehension in the function was basically really <strong>inefficient</strong>. It became super obvious once I narrowed down that <code>not_operation</code> was slow.</p>

<h3 id='optimisefix_ineffient_code'>Optimise/Fix ineffient code</h3>

<p>Excited to have found a possible bottleneck, I quickly implemented a fix.</p>
<div class='highlight'><pre><code class='python'><span class='c'># the fix.</span>
<span class='k'>def</span> <span class='nf'>not_operation</span><span class='p'>(</span><span class='n'>operand</span><span class='p'>,</span> <span class='n'>dictionary</span><span class='p'>,</span> <span class='n'>pfile</span><span class='p'>):</span>
    <span class='sd'>&quot;&quot;&quot;Performs the operation `NOT operand`.&quot;&quot;&quot;</span>

    <span class='c'># A list of all the documents (sorted)</span>
    <span class='n'>all_docs</span> <span class='o'>=</span> <span class='n'>dictionary</span><span class='o'>.</span><span class='n'>all_docs</span><span class='p'>()</span>

    <span class='c'># A list of the documents matching `operand` (sorted)</span>
    <span class='n'>results</span> <span class='o'>=</span> <span class='n'>get_results</span><span class='p'>(</span><span class='n'>operand</span><span class='p'>,</span> <span class='n'>dictionary</span><span class='p'>,</span> <span class='n'>pfile</span><span class='p'>,</span> <span class='n'>force_list</span><span class='o'>=</span><span class='bp'>True</span><span class='p'>)</span>

    <span class='k'>return</span> <span class='n'>list_a_and_not_list_b</span><span class='p'>(</span><span class='n'>all_docs</span><span class='p'>,</span> <span class='n'>results</span><span class='p'>)</span>


<span class='k'>def</span> <span class='nf'>list_a_and_not_list_b</span><span class='p'>(</span><span class='n'>a</span><span class='p'>,</span> <span class='n'>b</span><span class='p'>):</span>
    <span class='sd'>&quot;&quot;&quot;Returns `a AND NOT b`.</span>

<span class='sd'>    Both a and b are expected to be sorted lists.</span>

<span class='sd'>    &quot;&quot;&quot;</span>
    <span class='n'>results</span> <span class='o'>=</span> <span class='p'>[]</span>
    <span class='n'>idx_a</span> <span class='o'>=</span> <span class='mi'>0</span>
    <span class='n'>idx_b</span> <span class='o'>=</span> <span class='mi'>0</span>
    <span class='k'>while</span> <span class='n'>idx_a</span> <span class='o'>&lt;</span> <span class='nb'>len</span><span class='p'>(</span><span class='n'>a</span><span class='p'>)</span> <span class='ow'>and</span> <span class='n'>idx_b</span> <span class='o'>&lt;</span> <span class='nb'>len</span><span class='p'>(</span><span class='n'>b</span><span class='p'>):</span>
        <span class='k'>if</span> <span class='n'>a</span><span class='p'>[</span><span class='n'>idx_a</span><span class='p'>]</span> <span class='o'>&lt;</span> <span class='n'>b</span><span class='p'>[</span><span class='n'>idx_b</span><span class='p'>]:</span>
            <span class='n'>results</span><span class='o'>.</span><span class='n'>append</span><span class='p'>(</span><span class='n'>a</span><span class='p'>[</span><span class='n'>idx_a</span><span class='p'>])</span>
            <span class='n'>idx_a</span> <span class='o'>+=</span> <span class='mi'>1</span>
        <span class='k'>elif</span> <span class='n'>b</span><span class='p'>[</span><span class='n'>idx_b</span><span class='p'>]</span> <span class='o'>&lt;</span> <span class='n'>a</span><span class='p'>[</span><span class='n'>idx_a</span><span class='p'>]:</span>
            <span class='n'>idx_b</span> <span class='o'>+=</span> <span class='mi'>1</span>
        <span class='k'>else</span><span class='p'>:</span>
            <span class='n'>idx_a</span> <span class='o'>+=</span> <span class='mi'>1</span>
            <span class='n'>idx_b</span> <span class='o'>+=</span> <span class='mi'>1</span>

    <span class='k'>while</span> <span class='n'>idx_a</span> <span class='o'>&lt;</span> <span class='nb'>len</span><span class='p'>(</span><span class='n'>a</span><span class='p'>):</span>
        <span class='n'>results</span><span class='o'>.</span><span class='n'>append</span><span class='p'>(</span><span class='n'>a</span><span class='p'>[</span><span class='n'>idx_a</span><span class='p'>])</span>
        <span class='n'>idx_a</span> <span class='o'>+=</span> <span class='mi'>1</span>

    <span class='k'>return</span> <span class='n'>results</span>
</code></pre></div>
<h2 id='measure_again'>Measure again</h2>

<p>Measuring the time taken showed promising results. With this fix, the time taken dropped from roughly 1.5s to 1.15s.</p>
<div class='highlight'><pre><code class='bash'><span class='nb'>time </span>python search.py
<span class='c'># real    0m1.160s</span>
<span class='c'># user    0m1.018s</span>
<span class='c'># sys     0m0.133s</span>
</code></pre></div>
<p>Profiling the code showed that the slowness was no longer coming from <code>not_operation</code>.</p>

<p><img alt='cprofilev4-not-operation' src='/img/blog/cprofilev4-not-operation.png' /></p>

<h2 id='rinse_and_repeat'>Rinse and repeat</h2>

<p>This time though, the most of the time seemed to be spent in the <code>list_a_and_not_list_b</code> operation.</p>

<p><img alt='cprofilev5-bool-operation' src='/img/blog/cprofilev5-bool-operation.png' /></p>

<p>In particular, I seemed to be doing ~200k <code>len</code> operations and ~115 <code>append</code> operations on some list objects.</p>

<p>This seemed like a red-flag so I took a closer look at the <code>list_a_and_not_list_b</code> function.</p>

<p>It turns out that I really didn&#8217;t need the while loop at the end of the function.</p>
<div class='highlight'><pre><code class='python'><span class='c'># From this.</span>
<span class='k'>while</span> <span class='n'>idx_a</span> <span class='o'>&lt;</span> <span class='nb'>len</span><span class='p'>(</span><span class='n'>a</span><span class='p'>):</span>
    <span class='n'>results</span><span class='o'>.</span><span class='n'>append</span><span class='p'>(</span><span class='n'>a</span><span class='p'>[</span><span class='n'>idx_a</span><span class='p'>])</span>
    <span class='n'>idx_a</span> <span class='o'>+=</span> <span class='mi'>1</span>

<span class='c'># To this.</span>
<span class='n'>results</span><span class='o'>.</span><span class='n'>extend</span><span class='p'>(</span><span class='n'>a</span><span class='p'>[</span><span class='n'>idx_a</span><span class='p'>:])</span>
</code></pre></div>
<p>Measuring with this new change:</p>
<div class='highlight'><pre><code class='bash'><span class='nb'>time </span>python search.py
<span class='c'># real    0m0.895s</span>
<span class='c'># user    0m0.771s</span>
<span class='c'># sys     0m0.122s</span>
</code></pre></div>
<p><em>Woot! Got it to run under a second!</em></p>

<h2 id='summary'>Summary</h2>

<p>Overall, I&#8217;m pretty happy with the performance gain I got. I did a couple more that I didn&#8217;t cover here (some other boolean operations were performing poorly under other testcases). Its a pretty cool feeling to methodically find bottlenecks and fix them.</p></section>
</article></div>
            
            <footer>
                <a href="https://github.com/ymichael" target="_blank">
                    <div class="icon github"></div>
                </a>
                <a href="http://twitter.com/_ymichael" target="_blank">
                    <div class="icon twitter"></div>
                </a>
                <a href="https://www.quora.com/Michael-Yong" target="_blank">
                    <div class="icon quora"></div>
                </a>
            </footer>
        </div>
    </body>
    <script>
        // Google Analytics.
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-32478148-1', 'yrmichael.com');
        ga('send', 'pageview');
    </script>
</html>
