webpackJsonp([0xd24a8f980d05],{366:function(e,t){e.exports={data:{markdownRemark:{html:'<p>This blog post is part learning notes and part open thoughts on how to make\nsense of the myriad of great information available for web developers trying to\nprofile/optimize their sites.</p>\n<p>A large part of this is understanding how pages load in browsers and where the\nbiggest bottlenecks are. Very broadly, time taken for a page to load can be\nbroken down into time spent <em>inside</em> your server (generating the page), and time\nspent outside your server (network and in the browser). Most often, the latter\nis going to be a large chunk of the time taken. To quote: <a href="https://www.nateberkopec.com/2015/10/07/frontend-performance-chrome-timeline.html">Nate Berkopec\'s\nmust-read piece on Ludicriously Fast Page\nLoads</a><sup id="fnref-0"><a href="#fn-0" class="footnote-ref">0</a></sup>:</p>\n<blockquote>\n<p>Server response times, while easy to track and instrument, are ultimately a\nmeaningless performance metric from an end-user perspective. End-users don\'t\ncare how fast your super-turbocharged bare-metal Node.js server is - they care\nabout the page being completely loaded as fast as possible.</p>\n</blockquote>\n<p>Broadly, there are a number of variables that affect your page\'s performances.\nThings like network latency, payload size, assets, actual markup on your page,\nproper caching etc. This post focuses on time spent outside your server and some\nthings you should be thinking about.</p>\n<!--more-->\n<h2>What do we really care about?</h2>\n<p>Two things you probably should care about for a page load are:</p>\n<ol>\n<li><strong>How long before your users see anything?</strong></li>\n<li><strong>How long before your users can interact with the component you care most\nabout?</strong> <em>(eg. Submit some content, Expand some truncated content, Perform some\naction)</em></li>\n</ol>\n<p>Its hard to underscore just how important executing well on these two things\nare. <em>You\'ve already gone through the trouble of building a really great product\nthat people want to see/use. The countless hours of engineering/ranking/pixel\npushing is all for nought if the user leaves before viewing any of it.</em></p>\n<p><strong>Before 1, your users are just staring at a loading spinner and a blank page</strong> -\nmaking this a particularly important period of time that stands between your\nusers and the content they care about <em>(which is why they are visiting your site\nin the first place)</em>. This is the basis for the term \'Critical Render Path\'.\nThere are a lot of resources on how to optimize it and this is exactly what it\ndoes: reducing the time between users and your site\'s content.</p>\n<blockquote>\n<p>Optimizing the critical rendering path refers to prioritizing the display of\ncontent that relates to the current user action.<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup></p>\n</blockquote>\n<p><strong>After 1 and before 2, users can see your content but are unable to interact\nwith your site</strong>. They can\'t perform any actions on your site (like leave a\ncomment, read more etc). I think about the relationship between these two\ndifferent things as: The first makes sure that users stick around long enough\nto matter.  The second ensures that users have a good experience quickly and are\nable to perform actions they/you care about.</p>\n<p>For both these things, we want to:</p>\n<ol>\n<li>Track it as a metric effectively.</li>\n<li>Understand what actually blocks it from happening sooner.</li>\n<li>Diagnose, investigate and fix and relevant blockers.</li>\n</ol>\n<h2>Understanding page loads</h2>\n<p>One thing that makes it hard to reason/think about page load performance is that\nthere\'s just so much going on for just a <em>simple</em> request.</p>\n<p>A really <em>handwavvy</em> list of things that happen during a page load/request:</p>\n<ol>\n<li>Browsers request a page</li>\n<li>DNS lookup <em>(if not cached already)</em></li>\n<li>Redirect maybe?</li>\n<li>TCP connection</li>\n<li>TLS <em>(if is https, session resumption maybe?)</em></li>\n<li><em>Server does its work</em></li>\n<li>First byte</li>\n<li>Gets the HEAD</li>\n<li>Parses the incoming HTML</li>\n<li>Sees a CSS link tag.</li>\n<li>Request CSS <em>(we cannot paint till we get this)</em></li>\n<li>Sees a JS subresource <em>(is it async?, if not, block till we get it)</em></li>\n<li>Can we paint yet? Is CSS in yet?</li>\n<li>...</li>\n<li>first paint - User sees content <em>(but probably cannot click on things yet\nbecause Javascript..)</em></li>\n<li>User is able to interact with content</li>\n<li><em>... (images come in, async js comes in)</em></li>\n<li>window.onload event.</li>\n</ol>\n<p>Add cache misses, spotty connections, multiple connections at once and it becomes\nreally hard to intuitively figure out which parts are contributing the most to\nthe slowness or waiting time.</p>\n<p>Oh yea, if you use web fonts. There\'s that too<sup id="fnref-7"><a href="#fn-7" class="footnote-ref">7</a></sup>. Browsers don\'t like\nprefetching fonts until they realise they actually need it. They also dislike\nrendering system fonts while waiting and requesting for your fancy web font<sup id="fnref-8"><a href="#fn-8" class="footnote-ref">8</a></sup>,\nleading to more time before users see your content.<sup id="fnref-18"><a href="#fn-18" class="footnote-ref">18</a></sup></p>\n<p>I left out where most of the navigation timing events fire in the list above -\nthings like DOMInteractive DOMContentLoaded etc because they depend to some\nextent on the mark up on your page.</p>\n<p>For a more in-depth deep dive into the nitty gritty details that go into a page\nload: you should read <a href="https://www.nateberkopec.com/2015/10/07/frontend-performance-chrome-timeline.html">Nate\'s post</a>\nlinked above. This <a href="https://www.youtube.com/watch?v=XeMDXlJ051s">video</a> also\ndoes a good job describing some of the basics of how browsers treat JS and CSS\nwith respect to rendering.</p>\n<h2>The Numbers</h2>\n<p>The great thing about the current state of client side performance is that there\nare lots of browser APIs and information available to track the numbers we\nreally care about:</p>\n<ul>\n<li>There\'s the <strong>Navigation Timing API</strong><sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> - which basically contains timestamps of\nevents related to the page load</li>\n<li>There\'s <strong>First Paint</strong><sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> available on some browsers, that tell you when the\nbrowser first painted something visually to the user.</li>\n<li>There\'s the <strong>Resource Timing API</strong><sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> - which is basically Navigation Timing but\nfor your subresources (JS, CSS, Images etc)</li>\n</ul>\n<p>There\'s a really nice <a href="http://kaaes.github.io/timing/">bookmarklet</a><sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup> that makes\nis really easy to visualize and reason about navigation timing information. It\nproduces something like this:</p>\n<p><img src="/static/img/blog/navtiming.png" alt="navigation timing visualization"></p>\n<p>It breaks up the various phases of a request into network, server and browser\nwhich makes it really intuitive to reason about. I highly recommend giving it a\ngo. <em>I find it particularly useful to visualize navigation timing under multiple\ndifferent conditions (network, cache etc) and try and figure out when certain subresources\ncome in, paint happens etc without looking at the actual network tabs just to\ntest my understanding of what is happening. It works wonders. No, really.</em></p>\n<h2>How long before your users see anything? <em>(aka First Meaningful Paint)</em></h2>\n<p>Earlier in this post, I mentioned that we really care about two things. This is\nthe first of them. One way to measure this is via the first paint event which\ngives us a good proxy to when users begin to see content. <strong>However it important\nto be aware that this number potentially isn\'t meaningful to the extent that\nyour first paint doesn\'t show anything useful to the user</strong>.</p>\n<p>The real number we want that\'s a little harder to measure is first <em>meaningful</em>\npaint.</p>\n<p>Take the following filmstrip of &#x3C;quora.com> as an example:</p>\n<p><img src="/static/img/blog/quora-filmstrip.png" alt="Quora film strip"></p>\n<p>First paint happened at 779ms but really, we care about the paint at 1.37s.\nUsers care about the pain at 1.37s. I\'m not sure how to go about measuring this\nin production easily but this particular differentiation helps us to the extent\nthat we can go about debugging slow paint times with a better idea of what we\'re\ntrying to move.</p>\n<p>Oh, if you\'re wondering how I got this filmstrip, you can thank that awesome\npeople working on Chrome DevTools<sup id="fnref-13"><a href="#fn-13" class="footnote-ref">13</a></sup>. <em>You probably can figure this out by\njust fiddling with devtools for a bit - hint: its in the network tab and an icon\nthat looks like a video camera</em>.</p>\n<p>First paint is blocked by a number of things:</p>\n<ol start="0">\n<li>\n<p><strong>TTFB (Time to first byte)</strong>: Often, network latency is going to be a big\nfactor for first paint. You want to make sure that your server responds\nquickly<sup id="fnref-14"><a href="#fn-14" class="footnote-ref">14</a></sup> which basically involves auditing everything that happens\nbetween request start and first byte which involves the DNS lookup, initial\nTCP handshake, TLS negotiation ... up to when your server returns its first\nbyte.</p>\n</li>\n<li>\n<p><strong>HTML</strong>: This is obvious but your content needs to be there before the\nbrowser can render it. Often, you\'d want to prioritise above the fold (stuff\nthe user can see and is in their viewport) and your HTML/markup should\nreflect that.<sup id="fnref-15"><a href="#fn-15" class="footnote-ref">15</a></sup></p>\n</li>\n<li>\n<p><strong>CSS payload</strong>: If you have any external stylesheet, this needs\nto be fetched before the browser will render anything after it. If your users\nhave to fetch 50KB of css just to see the logo of your site, you probably\nhave some low hanging wins there.</p>\n<blockquote>\n<p>By default CSS is treated as a render blocking resource, which means that\nthe browser will hold rendering of any processed content until the CSSOM is\nconstructed. Make sure to keep your CSS lean, deliver it as quickly as\npossible, and use media types and queries to unblock rendering.<sup id="fnref-16"><a href="#fn-16" class="footnote-ref">16</a></sup></p>\n</blockquote>\n</li>\n<li>\n<p><strong>Blocking JS</strong>: Any non async javascript tag is going to block rendering of\ncontent after it. This really shouldn\'t be happening but its something to\nbe aware of since you might need this for certain things. <em>Its always worth\nconsidering if any time spent here blocking paint can be spent after we paint\ninstead.</em></p>\n</li>\n</ol>\n<p>Using a combination of Navigation Timing and Resource Timing, we can figure out\nwhen and how often any of the above blocks first paint. This will probably\ndiffer based on your mark up and what optimizations you have in place. It\'ll\nalso vary based on cache hit/miss cases.</p>\n<p>Knowing which of these form the bottleneck for you application\'s first paint can\ngo a long way in helping you meaningfully work towards make it faster. Oh I\nhighly recommend watching/reading a number bunch of perf\naudits<a href="">^9</a><a href="">^11</a> in the wild - very informative and practically\napplicable.<sup id="fnref-17"><a href="#fn-17" class="footnote-ref">17</a></sup></p>\n<h3>How long before your users an interact with stuff they care about?</h3>\n<p>This second metric is a little more tricky and varies more based on the set up of\nyour javascript and the purpose of your page.<em>For clarification, this shouldn\'t\nbe confused with the DOMInteractive event in Navigation Timing</em>. What I\'m\nreferring to here is something that you\'ll probably need to define for your site</p>\n<ul>\n<li>some core action that users take when on your site that relies on javascript.</li>\n</ul>\n<p>The reason top level metrics and numbers in navigation timing here break down is\nthat they aren\'t granular enough. For instance:</p>\n<ul>\n<li><code class="language-text">LoadEventEnd</code> is probably an upper bound of this number but probably includes\na lot of unnecessary things like images that probably make it more noisy than\nwe\'d like. As your javascript complexity increases, you probably have some\nlong tail of interactions that you don\'t care as much and timeliness is less\nimportant there.</li>\n<li><code class="language-text">DOMContentLoaded</code> is fired when your intial DOM is completely loaded and\nparsed but doesn\'t account for async javascript files which probably/might be\nrequired before your core action is functional.</li>\n</ul>\n<p><em>I find this <a href="http://kaaes.github.io/timing/info.html">page</a> really useful as a\ncheatsheet on what each event in Navigation Timing means and often find myself\nreferring to it.</em></p>\n<h2>Closing thoughts</h2>\n<p>There\'s an age old adage about measuring and profiling before trying to optimise\nanything. There\'s no reason why it shouldn\'t hold true for client side\nperformance. More often than not, I\'ve been surprised when measuring something\nor when some improvement didn\'t move some metrics as much as I expected it to.</p>\n<p>In the above two client side page load metrics, there are often multiple variables\nthat affect them for different sets of users: things like users on mobile, new\nusers (more cache misses) - making it all the more important to first have a\ngood understanding of where the bottlenecks in your site actually are.</p>\n<h2>Footnotes</h2>\n<div class="footnotes">\n<hr>\n<ol>\n<li id="fn-0">\n<p>No seriously, if you had to choose, just read his post and skip this.</p>\n<a href="#fnref-0" class="footnote-backref">↩</a>\n</li>\n<li id="fn-1">\n<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API">Navigation Timing API - MDN</a></p>\n<a href="#fnref-1" class="footnote-backref">↩</a>\n</li>\n<li id="fn-2">\n<p>Chrome - <code class="language-text">chrome.loadTimes().firstPaintTime</code>. You should probably use this <a href="https://github.com/addyosmani/timing.js/">library</a> by Addy Osmani.</p>\n<a href="#fnref-2" class="footnote-backref">↩</a>\n</li>\n<li id="fn-3">\n<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API/Using_the_Resource_Timing_API">Resource Timing API - MDN</a></p>\n<a href="#fnref-3" class="footnote-backref">↩</a>\n</li>\n<li id="fn-4">\n<p><a href="http://kaaes.github.io/timing/">http://kaaes.github.io/timing/</a></p>\n<a href="#fnref-4" class="footnote-backref">↩</a>\n</li>\n<li id="fn-5">\n<p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=en">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=en</a></p>\n<a href="#fnref-5" class="footnote-backref">↩</a>\n</li>\n<li id="fn-7">\n<p><a href="https://www.igvita.com/2014/01/31/optimizing-web-font-rendering-performance/">Good primer on best practices working with web fonts by Ilya Grigorik</a></p>\n<a href="#fnref-7" class="footnote-backref">↩</a>\n</li>\n<li id="fn-8">\n<p>Nice history on web font rendering - <a href="https://dev.opera.com/articles/better-font-face/">https://dev.opera.com/articles/better-font-face/</a></p>\n<a href="#fnref-8" class="footnote-backref">↩</a>\n</li>\n<li id="fn-9">\n<p><a href="https://github.com/reddit/reddit-mobile/issues/247">Paul Irish walks through Reddit Mobile in a PR</a></p>\n<a href="#fnref-9" class="footnote-backref">↩</a>\n</li>\n<li id="fn-10">\n<p><a href="http://www.paulirish.com/2015/advanced-performance-audits-with-devtools/">More Paul Irish Audits</a></p>\n<a href="#fnref-10" class="footnote-backref">↩</a>\n</li>\n<li id="fn-11">\n<p><a href="https://docs.google.com/document/d/1E2w0UQ4RhId5cMYsDcdcNwsgL0gP_S6SDv27yi1mCEY/edit?pref=2&#x26;pli=1">Perf audit of Tumblr\'s Dashboard</a></p>\n<a href="#fnref-11" class="footnote-backref">↩</a>\n</li>\n<li id="fn-12">\n<p><a href="http://www.perf-tooling.today/audits">http://www.perf-tooling.today/audits</a></p>\n<a href="#fnref-12" class="footnote-backref">↩</a>\n</li>\n<li id="fn-13">\n<p><a href="https://developers.google.com/web/updates/2015/07/devtools-digest-film-strip-and-a-new-home-for-throttling?hl=en">https://developers.google.com/web/updates/2015/07/devtools-digest-film-strip-and-a-new-home-for-throttling?hl=en</a></p>\n<a href="#fnref-13" class="footnote-backref">↩</a>\n</li>\n<li id="fn-14">\n<p><a href="https://plus.google.com/+IlyaGrigorik/posts/GTWYbYWP6xP">https://plus.google.com/+IlyaGrigorik/posts/GTWYbYWP6xP</a></p>\n<a href="#fnref-14" class="footnote-backref">↩</a>\n</li>\n<li id="fn-15">\n<p>The early bytes of your page are premium first class HTTP seats. Make them worth your while.</p>\n<a href="#fnref-15" class="footnote-backref">↩</a>\n</li>\n<li id="fn-16">\n<p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=en">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=en</a></p>\n<a href="#fnref-16" class="footnote-backref">↩</a>\n</li>\n<li id="fn-17">\n<p>I spend a lot of time trying to replicate and understand these perf audits. I highly recommend giving them a go.</p>\n<a href="#fnref-17" class="footnote-backref">↩</a>\n</li>\n<li id="fn-18">\n<p><code class="language-text">rel=preload</code> cannot come fast enough: <a href="https://www.bramstein.com/writing/preload-hints-for-web-fonts.html">https://www.bramstein.com/writing/preload-hints-for-web-fonts.html</a></p>\n<a href="#fnref-18" class="footnote-backref">↩</a>\n</li>\n</ol>\n</div>',frontmatter:{title:"Thoughts on Page Load Performance",date:"10 April, 2016"},fields:{slug:"/2016/04/10/thoughts-page-load-performance.html"}}},pathContext:{slug:"/2016/04/10/thoughts-page-load-performance.html"}}}});
//# sourceMappingURL=path---2016-04-10-thoughts-page-load-performance-html-4632cc109df86823bfa5.js.map